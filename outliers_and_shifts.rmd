---
title: 'Automated outlier and structural shift detection'
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_notebook:
    df_print: paged
    toc: yes
    toc_depth: 5
always_allow_html: yes    
    
editor_options: 
  chunk_output_type: console
---


# Setup code - run all of these chunks
<!-- setup chunk -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```


```{r system_specific_values, include=FALSE}
# ddir <- "C:/Users/donbo/Dropbox/DSRIP TSA_CA Team Info/chris_workflow/data/"
team_dir <- "C:/Users/donbo/Dropbox/DSRIP TSA_CA Team Info/"

chris_source_dir <- paste0(team_dir, "CMA Files/dsrip/chris_workflow/data/") # not used now

don_dir <- paste0(team_dir, "Don's Files/data/don/")
chris_dir <- paste0(team_dir, "Don's Files/data/chris_frozen/")

```


```{r globals, include=FALSE}
dsrip_start <- as.Date("2015-07-01")
```


```{r libraries, include=FALSE}
library("magrittr")
library("plyr") # needed for ldply; must be loaded BEFORE dplyr
library("tidyverse")
options(tibble.print_max = 60, tibble.print_min = 60) # if more than 60 rows, print 60 - enough for states
# ggplot2 tibble tidyr readr purrr dplyr stringr forcats

library("scales")
library("hms") # hms, for times
library("lubridate") # lubridate, for date/times
library("vctrs")

library("grDevices")
library("knitr")
library("kableExtra")

library("btools")

library("DT")

library("zoo") # for rollapply

library("broom") # for automating the cleanup of complex output
library("tsoutliers")

```


```{r functions_general, include=FALSE}
ns <- function(df) {names(df) %>% sort}


msr_name <- function(msr_id, measures_df=measures) {
  # return the measure name MSR_RESULT_NAME for a given measure id MSR_RESULT_ID
  # requires as input a dataframe that has both MSR_RESULT_ID and MSR_RESULT_NAME
  tibble(MSR_RESULT_ID=msr_id) %>%
    left_join(measures_df) %>%
    .$MSR_RESULT_NAME
}


pps_wrap <- function(PPS_ID, PPS_NAME, maxlen=100, wrap=25) {
  name <- str_sub(PPS_NAME, 1, maxlen)
  paste0(str_pad(PPS_ID, 2, pad="0"), ": ", name) %>% # zero-pad for better sorting
    str_wrap(wrap)
}


```


# START OF ANALYSIS -- with combined PPS/Statewide data
```{r getdata, include=FALSE}
# get previously created data
ppsdf <- readRDS(paste0(don_dir, "ppsall_ma.rds")) # monthly pps and statewide data, long
measures <- readRDS(paste0(don_dir, "measures.rds"))
ppsnames <- readRDS(paste0(don_dir, "ppsnames.rds"))
measures

# to be on the safe side make sure ppsdf is ungrouped and sorted
ppsdf <- ppsdf %>%
  ungroup %>%
  arrange(PPS_ID, MSR_RESULT_ID, PER_END_DT) 

```


```{r include=FALSE}
getout <- function(vec, crit.val=2.75, delta.val=0.7){
  # function to identify different kinds of outliers using the tsoutliers package
  #   vec is a numeric vector (sorted by time sequence)
  #   the return will be outdf, a data frame with information on outliers in the data, including their positions
  
  # kinds of outliers
  # An Additive Outlier (AO) represents an isolated spike
  # A Level Shift (LS) represents an abrupt change in the mean level
  # A Transient Change (TC) represents a spike that takes a few periods to disappear
  
  # focus on finding points that meet multiple criteria
  
  # the lower crit.val is, the more sensitive this is to outliers (the more likely to find them)
  # the default is NULL; values below about 3 seeem useful
  
  # lower delta.val also tends to find more outliers; 0.7 is default
  
  # look for each kind of outlier individually
  tsobj <- ts(vec, frequency=1) # the tso function requires a time-series object
  
  inner.loop <- 10
  outer.loop <- 6
  
  # get each of the 4 kinds of outliers separately, rather than all at once - I have found this to work well
  aom <- tsoutliers::tso(tsobj, types = "AO", 
             cval = crit.val, delta = delta.val, 
             maxit = 1, maxit.iloop = inner.loop, maxit.oloop = outer.loop, 
             tsmethod="arima",  args.tsmethod = list(order=c(1, 0, 0)))
  
  iom <- tsoutliers::tso(tsobj, types = "IO", 
             cval = crit.val, delta = delta.val, 
             maxit = 1, maxit.iloop = inner.loop, maxit.oloop = outer.loop, 
             tsmethod="arima",  args.tsmethod = list(order=c(1, 0, 0)))
  
  lsm <- tsoutliers::tso(tsobj, types = "LS", 
             cval = crit.val, delta = delta.val, 
             maxit = 1, maxit.iloop = inner.loop, maxit.oloop = outer.loop, 
             tsmethod="arima",  args.tsmethod = list(order=c(1, 0, 0)))
  
  tcm <- tsoutliers::tso(tsobj, types = "TS", 
             cval = crit.val, delta = delta.val, 
             maxit = 1, maxit.iloop = inner.loop, maxit.oloop = outer.loop, 
             tsmethod="arima",  args.tsmethod = list(order=c(1, 0, 0)))
  
  # create data frame with all 4 kinds of outliers
  outdf <- bind_rows(aom$outliers, iom$outliers, lsm$outliers, tcm$outliers)
  return(outdf)
}

vec <- df$MSR_RESULT
getao <- function(vec, crit.val=2.75, delta.val=0.7){
  # function to identify different kinds of outliers using the tsoutliers package
  #   vec is a numeric vector (sorted by time sequence)
  #   the return will be outdf, a data frame with information on outliers in the data, including their positions
  
  # kinds of outliers
  # An Additive Outlier (AO) represents an isolated spike
  # A Level Shift (LS) represents an abrupt change in the mean level
  # A Transient Change (TC) represents a spike that takes a few periods to disappear
  
  # focus on finding points that meet multiple criteria
  
  # the lower crit.val is, the more sensitive this is to outliers (the more likely to find them)
  # the default is NULL; values below about 3 seeem useful
  
  # lower delta.val also tends to find more outliers; 0.7 is default
  
  # look for each kind of outlier individually
  tsobj <- ts(vec, frequency=1) # the tso function requires a time-series object
  
  inner.loop <- 10
  outer.loop <- 6
  
  # get each of the 4 kinds of outliers separately, rather than all at once - I have found this to work well
  aom <- tsoutliers::tso(tsobj, types = "AO", 
             cval = crit.val, delta = delta.val, 
             maxit = 1, maxit.iloop = inner.loop, maxit.oloop = outer.loop, 
             tsmethod="arima",  args.tsmethod = list(order=c(1, 0, 0)))

  # create data frame with all 4 kinds of outliers
  outdf <- aom$outliers %>% select(type, ind, coefhat, tstat) %>% as_tibble
  
  # if there are no rows outdf is an empty data frame with wrong column types 
  # so if there are no rows create a 1-row df with proper types
  if(nrow(outdf)==0){
    # column types need to be as follows type factor, ind int, time num, coefhat num, tstat num
    outdf <- tibble(type=factor(), ind=integer(), coefhat=numeric(), tstat=numeric())
  }
  
  return(outdf)
}


```


# test the function on some known problems
```{r eval=FALSE}

# make a sample of smooth, breaks, outliers and other data
defs <- tribble(
  ~type, ~MSR_RESULT_ID, ~PPS_ID,
  "smooth", "AAPC20RES", 25,
  "smooth", "CAPC12MRES", 14,
  "smooth", "PDI14RES", 36,
  "break", "AMRRES", 40, # 1 break
  "break", "PPVRES", 33,
  "break-sharpfall", "CAPC12RES", 36,
  "outliers2", "AMMACUTRES", 48,
  "break", "AAPC20RES", 16,
  "break", "AAPC20RES", 19,
  "break", "AAPC45RES", 34,
  "break", "AMRRES", 52
) %>%
  mutate(groupnum=row_number()) %>%
  left_join(measures %>% select(MSR_RESULT_ID, MSR_RESULT_NAME)) %>%
  left_join(ppsnames)
defs
ns(defs)

test_data <- ppsdf %>% 
  select(MSR_RESULT_ID, PPS_ID, PER_END_DT, time, MSR_RESULT) %>%
  right_join(defs, by=c("MSR_RESULT_ID", "PPS_ID"))

gnum <- 10; getao(test_data$MSR_RESULT[test_data$groupnum==gnum])


f <- function(df) {getao(df$MSR_RESULT)} # ; getao(df$MSR_RESULT)}
f <- function(df) {head(df, 3)} 


grps <- c(1, 4, 9)
grps <- 1
d <- test_data %>%
  filter(groupnum %in% grps) %>%
  select(groupnum, PPS_ID, MSR_RESULT_ID, MSR_RESULT) %>%
  nest(data=MSR_RESULT) %>%
  mutate(out=map(data, f))

ns(test_data)
d <- test_data %>%
  select(groupnum, PPS_ID, MSR_RESULT_ID, time, MSR_RESULT) %>%
  nest(data=c(time, MSR_RESULT)) %>%
  mutate(out=map(data, f))
d
str(d$out)


outdf <- d %>%
  unnest(out, keep_empty = TRUE)

tmp <- outdf %>%
  select(groupnum, MSR_RESULT_ID, PPS_ID, ind) %>%
  filter(groupnum %in% c(4, 5, 8)) %>% 
  mutate(time=ind - 13)

tmp <- outdf %>%
  select(groupnum, MSR_RESULT_ID, PPS_ID, ind) %>%
  mutate(time=ind - 13)

tmp

brks <- c(seq(0, -30, -3) %>% rev, seq(3, 60, 3))
p <- test_data %>%
  # filter(groupnum %in% c(4, 5, 8)) %>%
  ggplot(aes(time, MSR_RESULT)) +
  geom_line() +
  geom_point() +
  scale_x_continuous(breaks=brks) +
  geom_vline(xintercept = 1, colour="blue", linetype="solid") +
  geom_vline(xintercept = 12, colour="blue", linetype="dashed") +
  # geom_vline(xintercept=tmp$time, colour="red") +
  geom_vline(aes(xintercept=time), colour="red", data=tmp) +
  theme(axis.text.x=element_text(angle=90, vjust=0.5)) +
  theme_bw() +
  facet_wrap(~MSR_RESULT_ID + PPS_ID, ncol=3, scales = "free") +
  theme(legend.position = "none")
p
glimpse(test_data)

f <- function(gnum) {
  badvals <- getao(test_data %>% filter(groupnum==gnum) %>% .$MSR_RESULT)
  return(badvals)
}
for(i in 1:10) print(f(i))
f(5)
gnum <- 1

fplot <- function(df){
  g <- function(gnum){
    outdf <- getao(df %>% filter(groupnum==gnum) %>% .$MSR_RESULT)
    badvals <- outdf$ind
    badvals
  }
  
  brks <- c(seq(0, -30, -3) %>% rev, seq(3, 60, 3))
  p <- df %>%
    ggplot(aes(time, MSR_RESULT)) +
    geom_line() +
    geom_point() +
    scale_x_continuous(breaks=brks) +
    geom_vline(xintercept = 1, colour="blue", linetype="solid") +
    geom_vline(xintercept = 12, colour="blue", linetype="dashed") +
    # geom_vline(xintercept=g() - 13, colour="red", data=.) +
    theme(axis.text.x=element_text(angle=90, vjust=0.5)) +
    theme_bw() +
    facet_wrap(~MSR_RESULT_ID + idname, ncol=3, scales = "free") +
    theme(legend.position = "none")
  p
}

fplot(test_data)
ns(test_data)

df <- test_data

```




